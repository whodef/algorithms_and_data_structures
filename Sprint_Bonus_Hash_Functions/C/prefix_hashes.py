"""
C. Префиксные хеши

_____________________________________________________________________________________________________
| Язык                    | Ограничение времени | Ограничение памяти |   Ввод        |   Вывод      |
_____________________________________________________________________________________________________
| Все языки               | 1 секунда           | 128Mb              |               |              |
| Node.js 14.15.5         | 5 секунд            | 128Mb              |               |              |
| Python 3.7.3            | 5 секунд  	        | 128Mb              | стандартный   | стандартный  |
| OpenJDK Java 11         | 2.5 секунд          | 128Mb              | ввод или      | вывод или    |
| C# (MS .NET 6.0 + ASP)  | 2.5 секунд          | 128Mb              | input.txt     | output.txt   |
| C# (MS .NET 5.0 + ASP)  | 2.5 секунд          | 128Mb              |               |              |
_____________________________________________________________________________________________________

Алла не остановилась на достигнутом — теперь она хочет научиться быстро вычислять хеши произвольных подстрок
данной строки. Помогите ей!

На вход поступают запросы на подсчёт хешей разных подстрок. Ответ на каждый запрос должен выполняться за O(1).
Допустимо в начале работы программы сделать предподсчёт для дальнейшей работы со строкой.

Напомним, что полиномиальный хеш считается по формуле:


В данной задаче необходимо использовать в качестве значений отдельных символов их коды в таблице ASCII.
h(s) = (s1a^n-1 + s2a^n-2 + ... + sn-1a+sn) mod m

Формат ввода:
В первой строке дано число a (1 ≤ a ≤ 1000) — основание, по которому считается хеш.
Во второй строке дано число m (1 ≤ m ≤ 107) — модуль. В третьей строке дана строка s (0 ≤ |s| ≤ 106), состоящая
из больших и маленьких латинских букв.

В четвертой строке дано число запросов t — натуральное число от 1 до 105. В каждой из следующих t строк записаны
через пробел два числа l и r — индексы начала и конца очередной подстроки. (1 ≤ l ≤ r ≤ |s|).


Формат вывода:
Для каждого запроса выведите на отдельной строке хеш заданной в запросе подстроки.
"""


def hashes_arr(b):
    # вычисление длины строки b и увеличение на 1 для создания массива хешей
    s_len = len(b) + 1
    # создание массива хешей с длиной s_len, заполненного нулями
    hashes = [0] * s_len
    # инициализация первого элемента массива хешей значением первого символа строки b
    hashes[1] = b[0]
    # цикл для вычисления хешей всех символов строки b
    for i in range(2, s_len):
        # вычисление хеша для символа под индексом i-1, используя предыдущий хеш и текущий символ
        hashes[i] = (hashes[i-1] * a + b[i-1]) % m
    return hashes


# Определение функции fast_pow, которая принимает три аргумента: число x, степень p и модуль r.
# Функция возвращает результат возведения числа x в степень p по модулю r.
def fast_pow(x, p, r):
    m = x % r
    t = 1
    while p:
        if p % 2:
            t *= m
            t %= r
        m *= m
        m %= r
        p //= 2
    return t % r


# считывание основания хеширования a
a = int(input().strip())
# считывание модуля m
m = int(input().strip())
# считывание строки, преобразование ее в байты, а затем передача функции hashes_arr для вычисления массива хешей
hashes = hashes_arr(bytes(input().strip(), encoding='ascii'))
# считывание числа запросов n
n = int(input().strip())

# создание массива результатов с длиной n, заполненного нулями
res = [0]*n
# цикл для обработки n запросов
for i in range(n):
    # считывание начала и конца подстроки
    s, e = input().strip().split()
    # преобразование начала и конца подстроки в целые числа
    start, end = int(s), int(e)
    # вычисление хеша подстроки, используя предподсчитанные хеши и быстрое
    # возведение в степень, и сохранение результата в массиве res.
    res[i] = (hashes[end] % m - hashes[start-1] * fast_pow(a, end- start + 1, m)) % m
# вывод результатов
print(*res, sep='\n')
