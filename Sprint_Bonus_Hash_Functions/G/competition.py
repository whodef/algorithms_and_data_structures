"""
G. Соревнование

_____________________________________________________________________________________________________
| Язык                    | Ограничение времени | Ограничение памяти |   Ввод        |   Вывод      |
_____________________________________________________________________________________________________
| Все языки               | 0.3 секунды         | 4Mb                | стандартный   | стандартный  |
| OpenJDK Java 11         | 0.5 секунды         | 64Mb               | ввод или      | вывод или    |
| C# (MS .NET 6.0 + ASP)  | 0.5 секунды         | 64Mb               | input.txt     | output.txt   |
| C# (MS .NET 5.0 + ASP)  | 0.5 секунды         | 64Mb               |               |              |
_____________________________________________________________________________________________________

Жители Алгосов любят устраивать турниры по спортивному программированию. Все участники разбиваются на пары
и соревнуются друг с другом. А потом два самых сильных программиста встречаются в финальной схватке, которая
состоит из нескольких раундов. Если в очередном раунде выигрывает первый участник, в таблицу с результатами
записывается 0, если второй, то 1. Ничьей в раунде быть не может.

Нужно определить наибольший по длине непрерывный отрезок раундов, по результатам которого суммарно получается
ничья. Например, если дана последовательность 0 0 1 0 1 1 1 0 0 0, то раунды с 2-го по 9-й
(нумерация начинается с единицы) дают ничью.


Формат ввода:
В первой строке задаётся n (0 ≤ n ≤ 105) –— количество раундов. Во второй строке через пробел
записано n чисел — результаты раундов. Каждое число равно либо 0, либо 1.


Формат вывода:
Выведите длину найденного отрезка.
"""

import sys


# Здесь используется подход, который называется "префиксная сумма", чтобы найти наибольший
# подмассив (или отрезок), где сумма элементов равна 0. В данном случае, он ищет наибольший
# подмассив, где количество нулей равно количеству единиц, что означает ничью в игре.
def competition():
    n = int(input())
    # Считываем результаты раундов, используя sys.stdin для
    # ускорения считывания большого количества данных.
    rounds = sys.stdin.readline().rstrip().split()
    # Инициализируем переменную max_len, которая будет
    # содержать длину наибольшего подмассива с ничьей.
    max_len = 0
    # Инициализируем переменную curr_sum, которая
    # будет содержать текущую префиксную сумму.
    curr_sum = 0
    # Создаём словарь hash_map для хранения префиксных сумм и их индексов.
    hash_map = {}

    for i in range(n):
        # Увеличиваем или уменьшаем текущую префиксную сумму
        # в зависимости от результата раунда.
        if rounds[i] == '1':
            curr_sum += 1
        else:
            curr_sum -= 1
        # Если текущая префиксная сумма равна нулю, то обновляем max_len,
        # так как подмассив от начала до текущего индекса включительно имеет сумму 0.
        if curr_sum == 0:
            max_len = i + 1
        # Если текущая префиксная сумма уже есть в hash_map, то обновляем max_len,
        # так как подмассив от индекса следующего после hash_map[curr_sum] до
        # текущего индекса имеет сумму 0.
        if curr_sum in hash_map:
            max_len = max(max_len, i - hash_map[curr_sum])
        else:
            # Если текущая префиксная сумма еще не встречалась,
            # то добавляет ее в hash_map с текущим индексом.
            hash_map[curr_sum] = i
    # Возвращаем длину наибольшего подмассива с ничьей.
    return max_len


if __name__ == '__main__':
    res = competition()
    print(res)
